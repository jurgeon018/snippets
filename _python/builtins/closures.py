############################################
# Corey Schafer


def outer_func(msg):
    def inner_func():
        print(msg)
    return inner_func


my_func = outer_func('Hi')
print(my_func.__name__)  # >> inner_func
print(my_func())  # >>> Hi

###################################################
# Олег Молчанов

# >> > def one():
#     x = ['one', 'two']
#
#     def inner():
#         print(x)
#         print(id(x))
#     return inner
#
# >> > o = one()
# >> > o
# <function one. < locals > .inner at 0x7fcd5c14e2f0 >
# >> > o()
# ['one', 'two']
# 140519989924552  # !!!
# >> > dir(o)
# [..., '__closure__', ...]
# >> > o.__closure__
# (< cell at 0x7fcd5c271af8: list object at 0x7fcd5c1552c8 > ,)
# >> > o.__closure__[0]
# <cell at 0x7fcd5c271af8: list object at 0x7fcd5c1552c8 >
# >> > dir(o.__closure__[0])
# [..., 'cell_contents', ...]
# >> > o.__closure__[0].cell_contents
# ['one', 'two']
# >> > a = o.__closure__[0].cell_contents
# >> > id(a)
# 140519989924552  # !!!
# >> > a
# ['one', 'two']
# >> > o()
# ['one', 'two']
# >> > a.append('asdf')
# >> > o()
# ['one', 'two', 'asdf']

# Замыкание - функция(inner) вместе с привязанной к ней совокупностью данных(переменная x, которая была обьявленна вне ее тела)
# Замыкание - функция, в теле которой есть ссылки на переменные, которые были обьявлены вне ее тела. При этом переменные, которые были обьявлены в охватывающей области видимости, не являются параметрами функции inner
# В замыканиях заменить def на class, one на One, и получили полноценный класс.
# Декораторы расширяют функционал функций - то же делает наследование в классах.
# Все те проблемы, которые можно решать с помощью замыканий, можно решать с помощью ООП


##############################################################
# Tceh

# Замыкания - возможность функции использовать не только свои, но и чужие переменные.
# Области видимости.
# Из глобальной области видимости нельзя получить доступ к локальным переменным
# Из локальной области видимости можно получить доступ к глобальным переменным
# Замыкание это:
# - возможность функции внутри своего локального фрейма использовать не только локальные переменные(свои) из локального фрейма, но и глобальные переменные(чужие) из глобального фрейма
# -возможность для функции использовать внешние данные.
# -Возможность для функции обратиться к данным, которые явным образом ей не принадлежат
# Для чтения глобальные переменные внутри функции можно использовать.
# Для изменения глобальной переменной внутри функции нужно использовать global(так не должно быть!!!)
# Вывод: функции могут читать и выводить глобальные обьекты, но не могут их перезаписывать
#
# После того как функция возвращает значение, и интерпретатор выходит из нее - приходит сборщик мусора и сьедает ее.
#
# Если глобальная переменная определена ПОСЛЕ вызова функции - функция не увидит эту переменную и будет NameError
#
# Обрабатывать исключения внутри функции или вовне?
# Вовне, потому что ты обладаешь полнотой контекста, и можешь сделать больше.
#
# Глобальные переменные из функции изменять\переназначать - нельзя, мутировать(.append()) - МОЖНО.
SOME_VAR = 12
OTHER = 'other'
GLOBAL_LIST = []


def print_var():
    test = '123'
    SOME_VAR += 1  # - ИЗМЕНЕНИЕ - НЕЛЬЗЯ!!!
    print(SOME_VAR, OTHER, test)


# print_var()  # >> >  UnboundLocalError: local variable 'some' referenced before assignment


def append_to_list(item):
    GLOBAL_LIST.append(item)  # - МУТИРОВАНИЕ - МОЖНО!!!!


append_to_list(1)
append_to_list(2)
print(GLOBAL_LIST)  # >> > [1, 2]
